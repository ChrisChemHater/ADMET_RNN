# -*- coding: utf-8 -*-
"""
Original data processing.
Node: Atom
Graph: Molecule
Tree: A connection tree of Nodes, generated by Graph.build_tree(), as the input of Recursive Neural Network
DataLoader: Class that processes datafile containing molecular structure in SMILES and Solubility data
-----------------------------------------------------------------------------------------------------------
Author: Chris
Department: Machine Learning Course directed by Prof.Liu, Peking University

log:
2019.12.13  modified DataLoader:
            1. return solubility values in torch.Tensor
            2. raw_data is divided into training set and testing set
"""

from rdkit import Chem
from rdkit.Chem import Draw

import numpy as np, pandas as pd
import json

import torch
from sklearn.model_selection import train_test_split


class Node(object):
    """
    Building block for both Graph and Tree, represent of atom.
    ----------------------------------------------------------------
    Example:
        atom_C = Node('C')
        atom_C_code = atom_C.atom
        atom_N = Node('N')
        atom_C.add_node(atom_N, 3)
        atom_N.add_node(atom_C, 3)
        bond_C_N_code = atom_C.bonds[0]
    """
    atoms = ('H', 'B', 'C', 'N', 'O', 'F', 'Si', 'S', 'P', 'Cl', 'As', 'Se', 'Br', 'I')  # symbols of elements
    atom_indexes = (1, 5, 6, 7, 8, 9, 14, 15, 16, 17, 33, 34, 35, 53)  # z of elements
    num_atoms = 14  # types of elements
    num_bonds = 3  # types of bonds

    def __init__(self, atom, atom_code=None):
        self.atom_label = self._convert_atom_to_label(atom)  # one of Node.atoms
        self.atom = atom_code if not (atom_code is None) else self._convert_atom_to_one_hot(
            atom)  # torch.Tensor, one_hot code of atom
        self.links = []  # nodes linked to self in graph
        self.bonds = []  # bonds between each linked node and self, in the form of one-hot code(torch.Tensor)
        self.children = []  # children nodes of self in tree
        self.tree_bonds = []  # bonds between each child node and self, in the form of one-hot code(torch.Tensor)
        self.color = 'white'  # color mark, "white" for undetected, "black" for detected, used in tree building.

    def add_node(self, new_node, bond_label=None, bond_code=None):
        """
        add node in molecule graph
        :param new_node: Node
        :param bond_label: int. One in [1,2,3]
        :param bond_code: torch.Tensor. More efficient way to build, unnecessary when bond_label is provided.
        :return: None
        """
        bond_code = bond_code if not (bond_code is None) else self._convert_bond_to_one_hot(bond_label)
        self.links.append(new_node)
        self.bonds.append(bond_code)

    def add_tree_node(self, new_node, bond_label=None, bond_code=None):
        """
        add node in molecule tree
        :param new_node: Node
        :param bond_label: int. One in [1,2,3]
        :param bond_code: torch.Tensor. More efficient way to build, unnecessary when bond_label is provided.
        :return: None
        """
        bond_code = bond_code if not (bond_code is None) else self._convert_bond_to_one_hot(bond_label)
        self.children.append(new_node)
        self.tree_bonds.append(bond_code)

    def has_child(self):
        return bool(self.children)

    def _convert_atom_to_label(self, atom_label):
        if type(atom_label) == str:
            return atom_label
        elif type(atom_label) == int:
            try:
                index = self.atom_indexes.index(atom_label)
                return self.atoms[index]
            except ValueError:
                print(f'Atom {atom_label} not found!')
                return atom_label

    def _convert_atom_to_one_hot(self, atom_label):
        atom_code = torch.zeros(size=(self.num_atoms,)).type(torch.float32)
        if type(atom_label) == str:
            try:
                index = self.atoms.index(atom_label)
                atom_code[index] = 1
            except ValueError:
                print(f'Atom {atom_label} not found!')
        elif type(atom_label) == int:
            try:
                index = self.atom_indexes.index(atom_label)
                atom_code[index] = 1
            except ValueError:
                print(f'Atom {atom_label} not found!')
        else:
            raise ValueError(f'Invalid Type {type(atom_label)} for atom_label. Expected Int or str')
        return atom_code

    def _convert_bond_to_one_hot(self, bond_label):
        bond_code = torch.zeros(size=(self.num_bonds,)).type(torch.float32)
        if bond_label in list(range(1, self.num_bonds + 1)):
            bond_code[bond_label - 1] = 1
        else:
            raise ValueError(f'Invalid Value {bond_label} for bond_label. Expected one in [1, 2, 3]')
        return bond_code

    @classmethod
    def one_hot_bond_to_label(cls, bond_code):
        for index, code in zip(range(1, cls.num_bonds + 1), bond_code):
            if code == 1:
                return index

    def __str__(self):
        return str(self.atom_label)

    def __repr__(self):
        return self.__str__()


class Tree(object):
    """
    Connection of Nodes in Tree Structure. A simple wrapper of Nodes, by quoting the root of tree.
    :param
    root_node: Node, the root of tree

    For more specific utilization, please check the doc of Class Node.
    """

    def __init__(self, root_node):
        self.root = root_node

    def __str__(self):
        """
        :return: str. The recursive expression of the tree.
        """
        if not self.root.children:
            return str(self.root.atom_label)
        string = f'{self.root.atom_label}-->({str(Node.one_hot_bond_to_label(self.root.tree_bonds[0])) + str(Tree(self.root.children[0]))}'
        for node, bond in zip(self.root.children[1:], self.root.tree_bonds[1:]):
            string += f'+{str(Node.one_hot_bond_to_label(bond)) + str(Tree(node))}'
        string += ')'
        return string

    def __repr__(self):
        return self.__str__()


class Graph(object):
    """
    Connection of Nodes in Graph Structure
    :param
    smiles_expr: str, SMILES expression of a molecule
    ----------------------------------------------------------------------------------------
    Example:
        acetone = Graph('CC(C)=O', batch_size=32)
        acetone.nodes    # viewing the atoms in acetone
        tree = acetone.build_tree(acetone.nodes[0])    # build a tree with C1 as its root
        for tree in acetone:
            print(tree)    # Go through each tree built on each atom in acetone molecule
    """

    def __init__(self, smiles_expr):
        self.smiles = smiles_expr
        self.nodes = []
        self._build_graph()
        self.size = len(self.nodes)

    def _build_graph(self):
        molecule = json.loads(Chem.MolToJSON(Chem.MolFromSmiles(self.smiles)))
        for atom in molecule['molecules'][0]['atoms']:
            atom_label = atom['z'] if 'z' in atom else molecule['defaults']['atom']['z']
            self.nodes.append(Node(atom_label))
        for bond in molecule['molecules'][0]['bonds']:
            bond_label = bond['bo'] if 'bo' in bond else molecule['defaults']['bond']['bo']
            Graph.add_node(self.nodes[bond['atoms'][0]], self.nodes[bond['atoms'][1]], bond_label)

    @classmethod
    def add_node(cls, node1, node2, bond_label):
        """
        Add node for both input node.
        :param node1: Node
        :param node2: Node
        :param bond_label: int. Bond type, one of [1,2,3]
        :return: None
        """
        node1.add_node(node2, bond_label)
        node2.add_node(node1, bond_label)

    def build_tree(self, root):
        """
        build a tree with minimum depth, on a specific root node.
        :param root: Node
        :return: Tree
        """
        self._color_init()
        root.color = 'black'
        self._build_tree_on_node(root)
        return Tree(root)

    def draw(self, show=False, fp=None):
        """
        Molecule visualizing.
        :param show: bool. Whether to show the picture of molecule structure
        :param fp: str or None. File path of the picture, with ".png", ".jpg" or ".eps", ".svg" as extensions.
                   None for don't save.
        :return: PIL.Image.
        """
        drawing = Draw.MolToImage(Chem.MolFromSmiles(self.smiles), size=(300, 300))
        if show:
            drawing.show()
        if fp:
            drawing.save(fp)
        return drawing

    def _color_init(self):
        for node in self.nodes:
            node.color = 'white'
            node.children = []
            node.tree_bonds = []

    def _build_tree_on_node(self, node):
        for link_node, bond in zip(node.links, node.bonds):
            if link_node.color == 'white':
                node.add_tree_node(link_node, bond_code=bond)
                link_node.color = 'black'

        for child_node in node.children:
            self._build_tree_on_node(child_node)

    def __iter__(self):
        self._pointer = 0
        return self

    def __next__(self):
        if self._pointer >= self.size:
            raise StopIteration
        tree = self.build_tree(self.nodes[self._pointer])
        self._pointer += 1
        return tree

    def __copy__(self):
        return


class DataLoader(object):
    """
    Data loader for Recursive Neural Network.
    In each iteration, the data in database are sampled randomly.
    :param
    filename: path of the database file
    batch_size: number of graphs in each iteration.
    splitting: fraction of test set, if None, raw data won't be split
    --------------------------------------------------------------------------
    Example:
        data = DataLoader(r'Small Delaney Data Set.txt', splitting=0.2)
        for batch_graphs, batch_values in data:
            # batch_graphs is wrapped in numpy.ndarray, while batch_values in torch.Tensor
            do_something(batch_graphs, batch_values)
        test_graphs, test_solubility = data.get_test_set()
    """

    def __init__(self, filename, batch_size=64, splitting=0.2):
        self.batch_size = batch_size
        raw_data = pd.read_csv(filename)
        self.smiles = raw_data['SMILES'].values
        self.solubility = raw_data['measured log(solubility:mol/L)'].values
        self.graphs = np.array([Graph(smiles) for smiles in self.smiles])
        if splitting:
            self.graphs, self.test_graphs, self.solubility, self.test_solubility = train_test_split(self.graphs,
                                                                                                    self.solubility)
            self.test_size = self.test_graphs.shape[0]
        self.train_size = self.graphs.shape[0]

    def get_test_set(self):
        try:
            return self.test_graphs, torch.from_numpy(self.test_solubility).type(torch.float)
        except AttributeError as e:
            print(
                f'DataLoader didn\'t split raw data into training and testing sets, try DataLoader(fp, splitting=0.2)')
            raise AttributeError

    def __iter__(self):
        self._pointer = 0
        return self

    def __next__(self):
        if self._pointer >= self.train_size:
            raise StopIteration
        sample_index = np.random.randint(0, self.train_size, size=(self.batch_size,))
        batch_graphs = self.graphs[sample_index]
        batch_solubility = torch.from_numpy(self.solubility[sample_index]).type(torch.float32)
        self._pointer += self.batch_size
        return batch_graphs, batch_solubility


def test():
    graph = Graph(r'CC(=O)CC(=O)C')
    for tree in graph:
        print(tree)

    data = DataLoader(r'Small Delaney Data Set.txt', batch_size=32)
    batch_graphs, batch_values = next(iter(data))
    print(batch_values)
